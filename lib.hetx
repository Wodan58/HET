/*
    module  : lib.hetx
    version : 1.9
    date    : 12/30/19
*/
( true t : ;
  false f : ;
* !) put_bool : ;
#define put_bool	put_bool * !

#define gc		gc $
#define add		add $
#define mul		mul $
#define less		less $
#define put		put $
#define putch		putch $

(a % ; b % ; a * b *) swap : ;
#define swap		swap * !

(swap less) greater : ;
#define greater		greater * !

#define true		t
#define false		f

(a % ; b % ; () a * + b * + > tt =) and : ;
#define and		and * !

(a % ; b % ; () a * + b * + > ff = f =) or : ;
#define or		or * !

(f =) not : ;
#define not		not * !

(/ swap ;) first : ;
#define first		first * !

( () t : ;
  (list * first prog * ! step_rec * !) f : ;
list * () = * !) step_rec : ;
#define step_rec	step_rec * !

( prog : ;		# pick up prog
  list : ;		# pick up list
step_rec) step : ;
#define step		step * !

( list : ;		# old list
  ()			# new list
list * (+) step) reverse : ;
#define reverse		reverse * !

(swap reverse (+) step) concat : ;
#define concat		concat * !

(reverse first) last : ;
#define last		last * !

( list : ;			# list
  elem : ;			# element
  f				# assume false
  ( (; t () list : ;) t : ;	# if equal: pop f, push t, and set list to ()
    () f : ;			# if not equal: do nothing
  elem * = * !) prog : ;	# program
step_rec) member : ;
#define member		member * !

(a % a *) dup : ;
#define dup		dup * !

( list : ;			# old list
  0				# initial value
  (add) prog : ;		# program
step_rec) sum : ;
#define sum		sum * !

32 space : ;
#define space		space *

( list : ;			# old list
  1				# initial value
  (mul) prog : ;		# program
step_rec) product : ;
#define product		product * !
